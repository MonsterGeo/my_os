
[toc]
# Boot Sequence

## post

当计算机开机或重启的时候，会运行一系列的诊断程序(POST)，这个程序最后会按照固件配置的顺序找到可启动设备，比如软盘、CD-ROM、或硬盘

## MBR

在一开始的时候，BIOS会检查可启动设备是否存在启动签名，也就是所谓的魔法数字(magic number)。启动签名位于启动扇区(0号扇区)中。0x55和0xAA分别位于前512字节的第510处和511处，当bios在扇区中找到这样的程序时，将加载其到0x0000:0x7c00处。

然后，执行流程会转移到新加载的引导记录，对于软盘，引导记录的全部512字节都包含可执行代码，但对于硬盘，MBR（主引导记录）在偏移量0x0000 - 0x01bd处储存可执行代码，随后是四个主分区的表项，每个表项占用16字节，地址范围在0x01be-0x01fd，最后是两个字节的签名0x01fe-0x01ff

## Early Environment

这个早期执行环境具有高度的实现相关性（具体取决于你所使用的 BIOS 实现）。切勿对寄存器内容做任何假设：它们可能被初始化为 0，也可能包含无效值。这一点同样适用于 FLAGS 寄存器和 SP 寄存器 —— 你甚至可能没有一个有效的栈！唯一可以确定的是，DL 寄存器中存储着加载你的引导代码的驱动器编号。
此时 CPU 处于实模式（Real Mode）下。（除非你运行在极少数特殊的 BIOS 上 —— 这类 BIOS 会自作主张为你激活保护模式（Protected Mode）。这意味着你不仅需要编写用于在其他硬件上激活保护模式的代码，还得添加一个判断条件，检查该模式是否已被激活。）

## kernel

最后，引导加载程序(bootloader)将内核加载到内存中并把控制权转给内核。

## loading

现在我们明白了需要加载的东西，我们接下来了解如何实现加载

如果从硬盘启动，那么你的引导记录只有446字节可用空间，对照内核镜像运行前完成的操作清单，你会发现这点空间远远不够

+ 确定要从哪个分区启动(要么查找活动分区，要么向用户展示已安装的操作系统供其选择)
+ 确定内核镜像在引导分区中的位置(从固定地方加载或解析文件系统)
+ 把内核加载到内存中
+ 启动保护模式
+ 为内核准备运行环境(比如分配栈空间)

这些操作不一定需要按顺序执行，但在调用内核的主函数(kmain())之前必须完成

更麻烦的是，GCC 仅生成保护模式可执行文件，因此早期执行环境所需的代码属于 “无法用 C 语言实现的功能” 之一。
针对该问题有以下几种解决方案：
极限压缩加载：将上述所有操作压缩进引导记录。这种方式几乎不可能实现，且无法预留空间处理特殊情况或输出有用的错误信息。
单阶段加载：编写一个用于模式切换的存根程序（stub program），并将其链接到内核镜像的开头。引导记录加载内核镜像（需加载到 1MB 内存地址以下，因为实模式下内存上限为 1MB），跳转到存根程序；存根程序完成保护模式切换和运行时环境准备后，再跳转到内核主体代码。
两阶段加载：编写一个独立的存根程序，将其加载到 1MB 内存地址以下，由该程序完成上述所有操作。

## The traditional way

传统上，MBR会把自身定位到内存地址0x0000:0x06xx，从分区表中识别出活动分区，然后加载分区的第一个扇区，即分区引导记录partition boot record到0x0000:0x7c00，最后跳转到该地址执行，这中方法叫链式加载(chain loading)，如果你希望自己编写的引导记录支持双启动(例如与windows共存双取)，就需要模拟这种行为

## Easy way out

除非你纯粹为了学习目的，执意要自己编写引导加载程序（引导记录 / 存根程序），否则我们建议使用现成的引导加载程序。
最常用的是 GRUB—— 一款两阶段引导加载程序。它不仅提供带有链式加载功能的启动菜单，还能将早期执行环境初始化到明确的标准状态（包括启用保护模式、从 BIOS 读取各类关键信息）；支持将通用可执行文件作为内核镜像加载（而非大多数其他引导加载程序要求的纯二进制文件），还兼容可选内核模块、多种文件系统，且若配置（./configure）得当，还支持无盘启动（Diskless Booting）

## Some methods

启动方案有多种可能的变体，以下仅列出部分方式，实际可能存在更多：
占用一个未使用的分区，直接加载第二阶段（stage 2）的原始代码；
将第二阶段（stage 2）放置在主引导记录（MBR）与第一个分区起始位置之间的区域；
（如 LILO 的实现方式）先生成内核文件，再通过工具检测该文件对应的扇区（或簇），之后让第一阶段（stage 1）从检测到的扇区列表中加载内核；
DOS 和 Windows 采用的方式：创建一个空文件系统（格式化分区），将内核放在根目录的第一个文件位置，shell 放在第二个文件位置。因此引导程序只需加载根目录的第一个文件（内核），再加载第二个文件（shell）即可；
早期 Linux 通过软盘启动的方式：第一个扇区（“boot” 扇区）以原始模式（无文件系统）加载第二阶段代码 —— 第二阶段是 “setup” 程序，存储在 “boot” 扇区后的连续扇区中；该第二阶段程序会完成系统初始化（如设置视频模式、获取内存映射等），随后加载真正的内核镜像（通常经 gzip、bzip2 等工具压缩）；
多年前曾有一款名为 “nuni” 的引导加载程序，能在单个引导扇区内完成保护模式切换和文件加载的全部操作。