# BabyStep 6


## Entering Protected mode
从这节开始，我们将跨过实模式，进入保护模式的学习中。

从实模式进入保护模式是切换特殊寄存器(cr0)中的某个位实现的。（其他的东西，诸如任务，IDT，调用门都是额外的玩意，暂时不是很关注。）

而现在，在切换保护模式前，你必须学会使用LGDT指令来加载另一个特殊寄存器(gdtr)，其中包含称为描述符的结构表位置，该描述符告诉我们进程如何访问内存。

## 描述符


一个描述符的结构如下：

|0|1|2|3|4|5|6|7|
|----|----|----|----|----|----|----|----|
|l0|l1|b0|b1|b2|TT|F1|b3|

描述符是从低位往高位排列的。



|0|0x00 段界限(Limit)的最低字节 |
|----|----|
|1|0x00 段界限的次低字节|
|2|0x00 基地址(Base Addr)的最低字节|
|3|0x00 基地址的次低字节|
|4|0x00 基地址的第三个字节|
|5|0x00 对应位结构为 0-00-0-0000，分别代表P(存在位)-DPL(特权级)-S(系统位)-Type(段类型)|
|6|0x00 对应位结构为0-0-0-0-0000 分别代表G(粒度位)-D/B(默认操作数大小)-R(保留位)-AVL(可用位)-Size(段大小位)|
|7|0x00，基地址的最高字节|

## 类型中的位(byte #5)


+ P（占1bit）：P是存在位，当P(Present) = 1时表示段在内存中（访问不存在的段会引起异常）
+ DPL(占2bit): 描述符特权级别,Level = 0表示最高，而Level = 3表示最低
+ S（占1bit）: 系统位，在任务状态段(TSS)描述符、中断描述符、陷阱门描述符、任务门描述符、调用门描述符中必须为0，反而对于代码段、数据段、栈段描述符，该位为1
+ Type(占4bit)：对该段的解读需要依赖前文提到的S位是否为1，若S = 0，则需要结合门描述符来解读该字段
+ Type类中的bit3: 该位用于确定数据段类型，若S = 1,此时bit3 = 1，则为代码段，否则bit3 = 0则是数据段
+ bit2 in Type: 若bit3 = 1（处于代码段），bit2表示段是否为一致性段，否则bit3 =0表示指定段作为栈使用时的扩展方向(上或者下)
+ 
| 段类型（由bit3决定） | bit3 | bit2 | 含义与效果                                                                 | 典型应用场景                                                                 |
|---|----|----|----|----|
| **代码段**           | 1    | 1    | 一致性代码段（Conforming Code Segment）<br>允许低特权级程序访问，且遵循调用方的特权级（无需权限提升）。 | 操作系统中供用户态程序调用的共享代码（如系统服务函数），确保需保证低权限程序可调用但受限于自身特权级。 |
| **代码段**           | 1    | 0    | 非一致性代码段（Non-Conforming Code Segment）<br>仅允许同特权级或更高特权级程序访问，低权限程序不可直接调用。 | 操作系统内核核心代码、敏感指令集，防止用户态程序未经授权访问。                   |
| **数据段（含栈段）** | 0    | 1    | 向下扩展数据段（Expand-Down Data Segment）<br>段空间从高地址向低地址增长，常用于动态调整大小的栈。 | 内核栈、需要动态扩容的栈（避免与其他内存区域冲突，防止栈溢出）。                 |
| **数据段（含栈段）** | 0    | 0    | 向上扩展数据段（Expand-Up Data Segment）<br>段空间从低地址向高地址增长，符合常规内存分配逻辑。       | 普通数据段（如全局变量、数组）、用户态程序的常规栈（栈顶随数据压入向高地址移动）。 |

+ bit1 in Type：对数据段，0表示只读，1表示可写。对于代码段，0表示无法读取，1表示可以
+ bit0 in type: 1表示该段被访问，0表示没有

## 标志位(byte #6)

+ G（占1bit）: 用于指定段大小的计量单位--值为0时，段大小以byte为单位，值为1，以4kb（页）为单位
+ D/B：默认操作数大小位/数据大小位(占1位)在代码段中用于指定默认操作数/地址的位数，值为1是32位，0是16位。在数据段中，该位用于指定栈指针的位数，1为32位，0是16位，即使用esp还是sp寄存器
+ R:保留位，给未来的英特尔
+ AVL:留给用户的，随便用
+ Size:该位是段界限的最高四位，定义段大小，与其余16位构成完整的20位段界限值，该位的作用取决于G，G = 0时，最大访问范围为1mb，而G =1时为4G. 

当G = 0,段的最大大小 =(20位段界限+1)字节，此时20位最大取值是0xFFFFF，所以最大的大小就是0xFFFFF+1 = 1048576bit = 1MB

G = 1时，段大小=(20位段界限+1)$\times$4kb，即4,294,967,296bits = 4GB

# BabyStep 7

## 虚拟模式

接下来的代码虽有点花哨，但理解它能让你初步明白保护模式的知识，并可能避免之后忽略此类内容而遇到的一些问题。

底部全局描述符（GDT）中的单个描述符，其布局和BabyStep 6是匹配的，该描述符给出的大小为1MB，基地址为0x0。其余位域可自行推导而出。

这样设计的目的是在实模式下支持32位偏移量，但目前的寻址方式还是只有1MB。

在保护模式下，段寄存器中的位3-15是描述符表的索引，这就是为什么下列代码中的0x08 = 1000b为您提供第一个条目[^1]


当寄存器分配一个选择子(selector)后，段描述符高速缓存寄存器会被填充描述符的值，其中包括大小(也就是段界限limit)。切换回实模式之后，无论16位寄存器中的值是什么，这些缓存的值都不会被改变，因此，原本16位段寄存器对应的64k段界限不会生效，此时可结合实模式的寻址规则，使用32位的偏移量。[^2]


[^1]: 0x08的二进制是1000，忽略低三位，高13位有效索引是1，因此指向表中的第一个描述符

[^2]: 按照这种方法寻址，即可突破64kb的限制($2^8$)，,公式是：段地址*16+16位偏移量，由于实模式下寄存器是16位，最大地址为0xFFFF，那么就有 ( 0xFFFF * 16)+0xFFFF = 0xFFFFF（1mb）


```nasm
; 编译方法：nasm boot.asm -o boot.bin
; partcopy boot.bin 0 200 -f0

[ORG 0x7c00] ;首次加载程序地址

start:
    xor ax,ax ; ax init
    mov ds,ax ;偏移量修改为0
    mov ss,ax ;栈偏移量修改为0
    mov sp,0x9c00 ;2000h后放程序

    cli ;关闭中断
    push ds ;把实模式的指针保存在栈里
    lgdt [gdtinfo] ;加载gdt寄存器信息

    ;切换保护模式
    mov eax,cr0      ;控制寄存器cr0的值给eax
    or al,1 ; 设置CR0的第0位，即pe位，保护模式允许位
    mov cr0 eax ;修改的值写回CR0，进入保护模式

    ;加载段选择子

    mov bx,0x08 ;选择描述符表中的第一个描述符 （0x08 = 1000b），高13位为1
    mov ds,bx   ;将数据段寄存器ds设置为这个选择子

    ;切换回实模式
    and al,0xFE ;清除PE，al是eax的低8位
    mov cr0,eax ;写回CR0回到实模式

    pop ds  ;恢复实模式下的数据段寄存器值
    sti     ;开启中断

    mov bx,0xf01    ;bx高8位是属性(0xf0表示黑底),低8位是字符(0x01是笑脸符号)
    mov eax,0x0b8000    ;eax存放显存地址。
    mov word [ds:eax] ,bx;写入显存

    jmp $

;GDT相关定义

gdtinfo:
   dw gdt_end - gdt - 1   ; GDT的大小（最后一个字节的偏移量）[^3]
   dd gdt         ; GDT的起始地址

gdt        dd 0,0  ; 定义为第0个描述符为空描述符
flatdesc    db 0xff, 0xff, 0, 0, 0, 10010010b, 11001111b, 0  ; 扁平模式描述符[^4]

gdt_end:
   ; 填充引导扇区剩余空间，使总大小为512字节
   times 510-($-$$) db 0  
   db 0x55          ; 引导扇区标志（最后两个字节必须是0x55AA）
   db 0xAA  
```

[^3]: gdt是起始地址,gdt_end是结尾，相减得到gdt的大小，-1就得到了限位值

[^4]: 前两个0xff是指限长低8位和次低8位都是0xff，后3个0是基地址的0到23位都是0x00。接着是字节5的定义: 10010010b，bit 7是P位，1是存在，表示该描述符有效，6-5位是0，即特权级为0，表示内核级。bit4是S位，1是指代码段/数据段。bit2是0表示向上拓展，即向高地址拓展，bit1是1表示可写，允许写入。最后Bit0表示该段没被访问过，处理器在访问后置1. 之后，字节6的bit 7(G)表示1是指限长为4kb，bit6（D/B）是1表示32位段，bit5(L)是0表示非64位，bit4(AVL)是0表示没被使用过，bit3-0(Size)表示限长高4位1111 = 0x0f。组合起来就是限长0xfffff，结合G位可知段大小为0xffff * 4kb = 1mb。最后字节7是0表示基地址的24-31位为0x00。这段描述符定义了一个0x00000000为基地址，大小为1mb(0x00000~0xfffff范围)。特权级为0，可读写的数据段

# BabyStep 8

## 32位打印

这里是与之前相同的非BIOS屏幕打印汇编例程，但调整为32位的偏移量和寄存器

```nasm
dochar:  
   call cprint    ;打印一个字符

sprint:
   mov eax, [esi]; ;把字符传入Al
   lea esi, [esi+1]; esi = esi+1
   cmp al,0 ;
   jne dochar ; 否则打印完成
   add byte [ypos],1 
   mov byte [xpos],0 
   ret

cprint:
   mov ah, 0x0F   ;字体为白，背景是黑
   mov ecx,eax    ; 保存字符属性
   movzx eax,byte[ypos]
   mov edx,160
   mul edx
   movzx ebx ,byte [xpos]
   shl ebx,1

   mov edi, 0xb8000 ;写入显示内存基地址
   add edi, eax;写入y偏移量
   add edi, ebx;写入x的偏移量

   mov eax, ecx ;恢复字符属性
   mov word [ds:edi], ax
   add byte [xpos], 1;位置+1

   ret

printreg32:
   mov edi, outstr32 
   mov eax, [reg32]
   mov esi,hexstr
   mov ecx,8; 32位程序包含8个16进制数，需要循环8次处理每个位

hexloop:
    rol eax,4  ;循环左移4位 
    mov ebx,eax ;左移后的值保存在bx中
    and ebx,0x0f; 保留低4位
    mov bl,[esi+ebx];esi存str的hex值，用ebx偏移存入指定字符到bl
    mov [edi], bl;
    inc edi
    dec ecx
    jnz hexloop

    mov esi,outstr32
    call sprint
    ret

xpos db 0
ypos db 0
hexstr db '0123456789ABCDEF'
outstr32 db '00000000' ,0
reg32 dd 0
```