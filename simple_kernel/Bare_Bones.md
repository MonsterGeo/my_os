[toc]

# Bare_Bones

在该节，我们将编写一个32位的 x86内核并启动它，这是我们创建操作系统的第一步，我们的目的是创建一个最小系统，而并非如何正确构建项目。这些指导原则经过社区审查，遵循当前推荐方案（且这些方案的设计均有充分依据）。请警惕网上大量的同类教程，它们大多不遵守现代技术建议，且多由缺乏经验的开发者编写，可能存在兼容性、安全和功能性问题。

我们即将开始新操作系统的开发之旅，或许未来某一天，我们的操作系统能够在自身环境下完成自我开发——这一过程被称为自举(bootstrapping) 或实现自托管(going self-hosted)。不过今天，我们只需要搭建一个基础系统，能在现有操作系统（宿主系统）中编译你的新操作系统（目标系统）。这一过程就是“交叉编译”(cross-compiling)，这是操作系统开发的第一步。


本文将使用现有技术来帮助你入门并迅速进入内核开发的部分，而不是让您开发自己的编程语言、编译器、或bootloader，本文中我们将使用

+ 使用来自Binutils的GNU链接器将您的目标文件链接成最终的内核
+ 来自Binutils的GNU汇编器（或选择NASM）用于将指令汇编翻译为包含机器码的目标文件
+ 来自GNU的编译器合集将您的高等级代码编译为汇编
+ 使用C或C++编写你的高等级内核代码
+ GRUB引导加载程序使用Multiboot引导协议来引导你的内核，该协议将我们加载到禁用分页的32位保护模式下
+ ELF作为可执行格式。给予我们控制内核加载位置和方式的能力

我们假定你正在使用类似于Linux的Unix-like操作系统，该系统对操作系统提供了良好的支持，Windows用户可在WSL、MinGW或Cygwin软件包中完成相应的操作

在操作系统开发领域取得成功，需要成为专家、保持耐心以及非常仔细地阅读所有指令。在继续之前，您需要阅读本文中的所有内容。如遇问题，您需要更加细致地重新阅读本文，并且为了确保效果，再进行三次操作。如果您仍然遇到问题，OSDev社区经验丰富，将乐意在论坛或IRC上提供帮助。

## 编译你的交叉编译器

文章:[GCC Cross-Compiler, Why do I need a Cross Compiler?](https://wiki.osdev.org/Why_do_I_need_a_Cross_Compiler%3F)

翻译：[编译GCC交叉编译器]()

你首先要做的是为 i686-elf 架构搭建一个 GCC 交叉编译器（GCC Cross-Compiler）。由于你尚未对编译器进行修改，使其能识别你的操作系统，因此需要使用一个名为 i686-elf 的通用目标架构 —— 它会为你提供一个面向 System V ABI（应用程序二进制接口）的工具链。该配置在操作系统开发（osdev）社区中经过了充分的测试和验证，能让你借助 GRUB（多引导加载程序）和 Multiboot（多引导规范）轻松搭建可引导的内核。（注意：如果你当前使用的是 Linux 等 ELF 平台，可能已经拥有能生成 ELF 格式程序的 GCC 编译器，但它并不适用于操作系统开发工作。因为这种编译器生成的程序是针对 Linux 系统的，而你的操作系统无论与 Linux 有多相似，都不是 Linux。如果不使用交叉编译器，后续必然会遇到问题。）
没有交叉编译器，你将无法正确编译自己的操作系统。
使用 x86_64-elf 架构的交叉编译器也无法完成本教程 —— 因为 GRUB 仅支持加载 32 位的 Multiboot 内核。如果这是你的第一个操作系统开发项目，应先从 32 位内核开始。若你改用 x86_64 编译器，且即便通过了后续的完整性检查，最终得到的内核也无法被 GRUB 识别并引导。

## 综述

现在，我们已经设置了编译器为i686-elf平台的格式，我们继续最小内核的示例（当然，也是基于x86操作系统的）。在示例中，你只需要三个输入文件：

+ boot.s 内核入口点，用于设置处理器环境
+ kernel.c 你的内核例程
+ linker.ld 链接上述文件用

## 启动操作系统

在操作系统被启动之前，将会先运行一段程序，这段程序被用来加载操作系统的，也被称为引导加载程序。等一下我们将看看怎么使用GRUB，配置/编写自己的引导加载程序。

你需要处理的第一个任务，就是了解引导加载程序如何启动内核。操作系统开发者（OSDevers）其实很幸运，因为存在一套多引导规范（Multiboot Standard）—— 它定义了引导加载程序与操作系统内核之间的简易交互接口。该规范的实现原理是：在一些全局变量中存入特定的 “魔数”（这些变量集合被称为多引导头部（multiboot header）），引导加载程序会主动搜索这些魔数。当检测到魔数时，引导加载程序就会识别出该内核符合多引导规范，进而知道如何加载它；甚至还能向内核传递内存映射（memory maps）等重要信息，不过目前你暂时用不到这些信息。
由于此时栈尚未建立，且你需要确保全局变量的配置无误，因此这部分工作需要通过汇编语言（assembly） 来完成